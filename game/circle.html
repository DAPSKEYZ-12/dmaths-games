<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle Theorem Challenge: Geometry Quest</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1300px;
            margin: 0 auto;
            background-color: rgba(255, 255, 255, 0.97);
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(to right, #203a43, #2c5364);
            color: white;
            padding: 25px;
            text-align: center;
            position: relative;
        }
        
        h1 {
            font-size: 2.6rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .tagline {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 900px;
            margin: 0 auto;
        }
        
        .game-container {
            display: flex;
            flex-wrap: wrap;
            padding: 20px;
            gap: 20px;
        }
        
        .left-panel {
            flex: 1;
            min-width: 350px;
            background-color: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }
        
        .right-panel {
            flex: 1.2;
            min-width: 350px;
            background-color: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }
        
        .panel-title {
            font-size: 1.5rem;
            color: #2c5364;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eaeaea;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .circle-container {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
            border: 2px solid #2c5364;
            position: relative;
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #circleCanvas {
            width: 100%;
            height: 380px;
            border-radius: 8px;
        }
        
        .theorem-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .theorem-btn {
            flex: 1;
            min-width: 120px;
            padding: 12px 15px;
            background-color: #e9ecef;
            border: 2px solid #adb5bd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
            color: #495057;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .theorem-btn:hover {
            background-color: #dee2e6;
            transform: translateY(-3px);
        }
        
        .theorem-btn.active {
            background-color: #2c5364;
            color: white;
            border-color: #203a43;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 24px;
            font-size: 1.1rem;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-primary {
            background-color: #2c5364;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #203a43;
            transform: translateY(-3px);
            box-shadow: 0 5px 10px rgba(44, 83, 100, 0.3);
        }
        
        .btn-secondary {
            background-color: #f8f9fa;
            color: #2c5364;
            border: 2px solid #2c5364;
        }
        
        .btn-secondary:hover {
            background-color: #e9ecef;
            transform: translateY(-3px);
        }
        
        .btn-help {
            background-color: #17a2b8;
            color: white;
        }
        
        .btn-help:hover {
            background-color: #138496;
            transform: translateY(-3px);
        }
        
        .stats {
            display: flex;
            justify-content: space-between;
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 25px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.05);
        }
        
        .stat-box {
            text-align: center;
            flex: 1;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #2c5364;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }
        
        .progress-container {
            margin-top: 25px;
        }
        
        .progress-bar {
            height: 20px;
            background-color: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        
        .progress {
            height: 100%;
            background: linear-gradient(to right, #203a43, #2c5364);
            width: 0%;
            transition: width 0.5s;
        }
        
        .progress-text {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: #666;
        }
        
        .feedback {
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            text-align: center;
            font-weight: bold;
            display: none;
            animation: fadeIn 0.5s;
        }
        
        .feedback.correct {
            background-color: rgba(40, 167, 69, 0.2);
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .feedback.incorrect {
            background-color: rgba(220, 53, 69, 0.2);
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .hint-container {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            margin-top: 25px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.05);
            display: none;
        }
        
        .hint-title {
            font-size: 1.2rem;
            color: #17a2b8;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .theorem-info {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.05);
        }
        
        .theorem-name {
            font-size: 1.3rem;
            color: #2c5364;
            margin-bottom: 10px;
        }
        
        .theorem-description {
            margin-bottom: 15px;
            line-height: 1.5;
        }
        
        .theorem-formula {
            font-family: 'Courier New', monospace;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            border-left: 4px solid #2c5364;
        }
        
        .quiz-container {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.05);
        }
        
        .quiz-question {
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        
        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .quiz-option {
            padding: 12px;
            background-color: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .quiz-option:hover {
            background-color: #e9ecef;
        }
        
        .quiz-option.selected {
            background-color: #d1ecf1;
            border-color: #17a2b8;
        }
        
        .quiz-option.correct {
            background-color: #d4edda;
            border-color: #28a745;
        }
        
        .quiz-option.incorrect {
            background-color: #f8d7da;
            border-color: #dc3545;
        }
        
        .history-item {
            background-color: white;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .history-theorem {
            font-weight: bold;
        }
        
        .history-result {
            color: #2c5364;
            font-weight: bold;
        }
        
        .correct-icon {
            color: #28a745;
        }
        
        .incorrect-icon {
            color: #dc3545;
        }
        
        footer {
            text-align: center;
            padding: 20px;
            color: #666;
            font-size: 0.9rem;
            border-top: 1px solid #eee;
        }
        
        .level-indicator {
            display: inline-block;
            background-color: #2c5364;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            margin-top: 10px;
        }
        
        .angle-display {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-weight: bold;
            color: #2c5364;
            pointer-events: none;
            z-index: 10;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .pulse {
            animation: pulse 0.5s;
        }
        
        @media (max-width: 900px) {
            .game-container {
                flex-direction: column;
            }
            
            .left-panel, .right-panel {
                width: 100%;
            }
            
            .theorem-btn {
                min-width: 100px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-circle"></i> Circle Theorem Challenge</h1>
            <p class="tagline">Master circle theorems through interactive visualizations and quizzes. Explore each theorem, solve problems, and test your geometry knowledge!</p>
            <div class="level-indicator">Level: <span id="level">1</span> | Theorems Mastered: <span id="theoremsMastered">0/8</span></div>
        </header>
        
        <div class="game-container">
            <div class="left-panel">
                <h2 class="panel-title"><i class="fas fa-drafting-compass"></i> Interactive Circle</h2>
                
                <div class="stats">
                    <div class="stat-box">
                        <div class="stat-value" id="score">0</div>
                        <div class="stat-label">Score</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="streak">0</div>
                        <div class="stat-label">Correct Streak</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="total">0</div>
                        <div class="stat-label">Questions Solved</div>
                    </div>
                </div>
                
                <div class="circle-container">
                    <canvas id="circleCanvas" width="500" height="380"></canvas>
                </div>
                
                <div class="theorem-selector">
                    <div class="theorem-btn active" data-theorem="angle-center">
                        <i class="fas fa-bullseye"></i> Central Angle
                    </div>
                    <div class="theorem-btn" data-theorem="angle-circumference">
                        <i class="fas fa-dot-circle"></i> Angle at Circumference
                    </div>
                    <div class="theorem-btn" data-theorem="cyclic-quadrilateral">
                        <i class="fas fa-shapes"></i> Cyclic Quadrilateral
                    </div>
                    <div class="theorem-btn" data-theorem="tangent-radius">
                        <i class="fas fa-draw-polygon"></i> Tangent & Radius
                    </div>
                </div>
                
                <div class="theorem-selector">
                    <div class="theorem-btn" data-theorem="alternate-segment">
                        <i class="fas fa-exchange-alt"></i> Alternate Segment
                    </div>
                    <div class="theorem-btn" data-theorem="chord-bisector">
                        <i class="fas fa-cut"></i> Chord Bisector
                    </div>
                    <div class="theorem-btn" data-theorem="intersecting-chords">
                        <i class="fas fa-times"></i> Intersecting Chords
                    </div>
                    <div class="theorem-btn" data-theorem="angle-semicircle">
                        <i class="fas fa-adjust"></i> Angle in Semicircle
                    </div>
                </div>
                
                <div class="controls">
                    <button class="btn btn-primary" id="exploreBtn">
                        <i class="fas fa-play-circle"></i> Explore Theorem
                    </button>
                    <button class="btn btn-help" id="hintBtn">
                        <i class="fas fa-lightbulb"></i> Show Explanation
                    </button>
                </div>
                
                <div class="controls">
                    <button class="btn btn-secondary" id="quizBtn">
                        <i class="fas fa-question-circle"></i> Test My Knowledge
                    </button>
                    <button class="btn btn-secondary" id="resetBtn">
                        <i class="fas fa-redo"></i> Reset Game
                    </button>
                </div>
                
                <div class="feedback" id="feedback"></div>
                
                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress" id="progress"></div>
                    </div>
                    <div class="progress-text">
                        <span>Mastery Progress</span>
                        <span id="progressPercent">0%</span>
                    </div>
                </div>
            </div>
            
            <div class="right-panel">
                <h2 class="panel-title"><i class="fas fa-graduation-cap"></i> Theorem Details</h2>
                
                <div class="theorem-info" id="theoremInfo">
                    <div class="theorem-name">Central Angle Theorem</div>
                    <div class="theorem-description">
                        The angle subtended at the center of a circle is twice the angle subtended at the circumference by the same arc.
                    </div>
                    <div class="theorem-formula">∠AOB = 2 × ∠ACB</div>
                    <div class="theorem-description">
                        Where A and B are points on the circumference, O is the center, and C is any point on the circumference on the same arc AB.
                    </div>
                </div>
                
                <div class="quiz-container" id="quizContainer" style="display: none;">
                    <div class="quiz-question" id="quizQuestion">What is the relationship between the central angle and the angle at the circumference?</div>
                    <div class="quiz-options" id="quizOptions">
                        <!-- Options will be added by JavaScript -->
                    </div>
                    <div class="controls" style="margin-top: 20px;">
                        <button class="btn btn-primary" id="submitQuizBtn">
                            <i class="fas fa-check"></i> Submit Answer
                        </button>
                        <button class="btn btn-secondary" id="nextQuizBtn" style="display: none;">
                            <i class="fas fa-forward"></i> Next Question
                        </button>
                    </div>
                </div>
                
                <div class="hint-container" id="hintContainer">
                    <h3 class="hint-title"><i class="fas fa-lightbulb"></i> Theorem Explanation</h3>
                    <div id="hintContent">
                        <!-- Hint content will be added by JavaScript -->
                    </div>
                </div>
                
                <h2 class="panel-title" style="margin-top: 30px;"><i class="fas fa-history"></i> Activity History</h2>
                <div id="historyList">
                    <!-- History items will be added here -->
                </div>
            </div>
        </div>
        
        <footer>
            <p>Circle Theorem Challenge - An interactive game to master circle theorems through visualization and practice</p>
            <p>Use this game to explore each theorem, understand its properties, and test your knowledge with interactive quizzes.</p>
        </footer>
    </div>

    <script>
        // Game state variables
        let score = 0;
        let streak = 0;
        let totalSolved = 0;
        let level = 1;
        let masteryProgress = 0;
        let currentTheorem = "angle-center";
        let masteredTheorems = new Set();
        let history = [];
        
        // Canvas and drawing context
        const canvas = document.getElementById('circleCanvas');
        const ctx = canvas.getContext('2d');
        
        // DOM elements
        const theoremInfoEl = document.getElementById('theoremInfo');
        const quizContainerEl = document.getElementById('quizContainer');
        const quizQuestionEl = document.getElementById('quizQuestion');
        const quizOptionsEl = document.getElementById('quizOptions');
        const submitQuizBtn = document.getElementById('submitQuizBtn');
        const nextQuizBtn = document.getElementById('nextQuizBtn');
        const exploreBtn = document.getElementById('exploreBtn');
        const hintBtn = document.getElementById('hintBtn');
        const quizBtn = document.getElementById('quizBtn');
        const resetBtn = document.getElementById('resetBtn');
        const feedbackEl = document.getElementById('feedback');
        const hintContainer = document.getElementById('hintContainer');
        const hintContent = document.getElementById('hintContent');
        const historyList = document.getElementById('historyList');
        const scoreEl = document.getElementById('score');
        const streakEl = document.getElementById('streak');
        const totalEl = document.getElementById('total');
        const levelEl = document.getElementById('level');
        const theoremsMasteredEl = document.getElementById('theoremsMastered');
        const progressEl = document.getElementById('progress');
        const progressPercentEl = document.getElementById('progressPercent');
        
        // Circle theorems data
        const theorems = {
            "angle-center": {
                name: "Central Angle Theorem",
                description: "The angle subtended at the center of a circle is twice the angle subtended at the circumference by the same arc.",
                formula: "∠AOB = 2 × ∠ACB",
                details: "Where A and B are points on the circumference, O is the center, and C is any point on the circumference on the same arc AB.",
                hint: "Draw lines from the center O to points A and B. Notice that triangle AOB is isosceles (OA = OB = radius). The angle at the center is the sum of angles in two smaller triangles."
            },
            "angle-circumference": {
                name: "Angles in the Same Segment",
                description: "Angles subtended by the same arc at the circumference are equal.",
                formula: "∠ACB = ∠ADB",
                details: "Where A and B are fixed points on the circumference, and C and D are any other points on the same arc AB.",
                hint: "Consider the central angle theorem: ∠AOB = 2 × ∠ACB and also ∠AOB = 2 × ∠ADB. Therefore, ∠ACB = ∠ADB."
            },
            "cyclic-quadrilateral": {
                name: "Cyclic Quadrilateral Theorem",
                description: "The opposite angles of a cyclic quadrilateral add up to 180°.",
                formula: "∠A + ∠C = 180°, ∠B + ∠D = 180°",
                details: "A cyclic quadrilateral has all its vertices on the circumference of a circle.",
                hint: "Draw the quadrilateral ABCD inscribed in the circle. The angles ∠A and ∠C subtend arcs that together make up the whole circle (360°)."
            },
            "tangent-radius": {
                name: "Tangent-Radius Theorem",
                description: "A tangent to a circle is perpendicular to the radius drawn to the point of tangency.",
                formula: "Radius OP ⟂ Tangent at P",
                details: "Where O is the center of the circle and P is the point where the tangent touches the circle.",
                hint: "Consider that the shortest distance from the center to the tangent line is along the radius to the point of tangency."
            },
            "alternate-segment": {
                name: "Alternate Segment Theorem",
                description: "The angle between a tangent and a chord through the point of contact is equal to the angle in the alternate segment.",
                formula: "∠TAB = ∠ACB",
                details: "Where T is the point of tangency, AB is a chord, and C is a point on the circumference in the alternate segment.",
                hint: "Draw the radius to the point of tangency, creating a right angle. Then use the fact that angles in a triangle sum to 180°."
            },
            "chord-bisector": {
                name: "Chord Bisector Theorem",
                description: "The perpendicular from the center of a circle to a chord bisects the chord.",
                formula: "If OM ⟂ AB, then AM = MB",
                details: "Where O is the center, AB is a chord, and M is the midpoint of AB.",
                hint: "Consider triangles OAM and OBM. They are right-angled triangles with OA = OB (radii) and OM common."
            },
            "intersecting-chords": {
                name: "Intersecting Chords Theorem",
                description: "When two chords intersect inside a circle, the products of the segments of each chord are equal.",
                formula: "AP × PB = CP × PD",
                details: "Where chords AB and CD intersect at point P inside the circle.",
                hint: "Draw triangles APC and BPD. They are similar triangles because their angles are equal (vertically opposite angles and angles in the same segment)."
            },
            "angle-semicircle": {
                name: "Angle in a Semicircle",
                description: "The angle in a semicircle is a right angle (90°).",
                formula: "If AB is a diameter, then ∠ACB = 90°",
                details: "Where A and B are endpoints of a diameter, and C is any point on the circumference.",
                hint: "Use the central angle theorem: the central angle for diameter AB is 180°, so the angle at the circumference is half of that, which is 90°."
            }
        };
        
        // Quiz questions for each theorem
        const quizQuestions = {
            "angle-center": {
                question: "If angle ACB at the circumference is 40°, what is the angle AOB at the center?",
                options: ["20°", "40°", "80°", "160°"],
                correct: 2
            },
            "angle-circumference": {
                question: "If angle ACB is 35° and both angles are subtended by the same arc AB, what is angle ADB?",
                options: ["35°", "70°", "17.5°", "140°"],
                correct: 0
            },
            "cyclic-quadrilateral": {
                question: "In a cyclic quadrilateral, if angle A is 70°, what is angle C?",
                options: ["70°", "110°", "20°", "90°"],
                correct: 1
            },
            "tangent-radius": {
                question: "What is the angle between a tangent and the radius at the point of contact?",
                options: ["45°", "60°", "90°", "180°"],
                correct: 2
            },
            "alternate-segment": {
                question: "If the angle between a tangent and a chord is 50°, what is the angle in the alternate segment?",
                options: ["25°", "50°", "100°", "130°"],
                correct: 1
            },
            "chord-bisector": {
                question: "If a radius is perpendicular to a chord and the chord length is 12cm, what is the length of each segment?",
                options: ["3cm", "6cm", "9cm", "12cm"],
                correct: 1
            },
            "intersecting-chords": {
                question: "Two chords intersect. One chord is divided into segments of 3cm and 4cm. The other chord is divided into segments where one is 6cm. What is the other segment?",
                options: ["2cm", "4.5cm", "8cm", "12cm"],
                correct: 0
            },
            "angle-semicircle": {
                question: "What is the angle at the circumference if the chord is a diameter?",
                options: ["45°", "60°", "90°", "180°"],
                correct: 2
            }
        };
        
        // Initialize game
        function initGame() {
            // Set up theorem buttons
            document.querySelectorAll('.theorem-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Remove active class from all buttons
                    document.querySelectorAll('.theorem-btn').forEach(b => b.classList.remove('active'));
                    
                    // Add active class to clicked button
                    this.classList.add('active');
                    
                    // Update current theorem
                    currentTheorem = this.dataset.theorem;
                    
                    // Update theorem info
                    updateTheoremInfo();
                    
                    // Draw the theorem
                    drawCircleTheorem();
                    
                    // Hide quiz and hint containers
                    quizContainerEl.style.display = 'none';
                    hintContainer.style.display = 'none';
                    feedbackEl.style.display = 'none';
                });
            });
            
            // Set up control buttons
            exploreBtn.addEventListener('click', () => {
                drawCircleTheorem(true); // Animate
                showFeedback(`Exploring ${theorems[currentTheorem].name}`, "correct");
            });
            
            hintBtn.addEventListener('click', showHint);
            
            quizBtn.addEventListener('click', showQuiz);
            
            resetBtn.addEventListener('click', resetGame);
            
            submitQuizBtn.addEventListener('click', checkQuizAnswer);
            
            nextQuizBtn.addEventListener('click', () => {
                quizContainerEl.style.display = 'none';
                feedbackEl.style.display = 'none';
                nextQuizBtn.style.display = 'none';
                submitQuizBtn.style.display = 'flex';
            });
            
            // Draw initial theorem
            drawCircleTheorem();
            
            // Add some initial history items
            addToHistory("Explored Central Angle Theorem", true);
            addToHistory("Took a quiz on Angles in Same Segment", false);
        }
        
        // Update theorem information display
        function updateTheoremInfo() {
            const theorem = theorems[currentTheorem];
            
            theoremInfoEl.innerHTML = `
                <div class="theorem-name">${theorem.name}</div>
                <div class="theorem-description">${theorem.description}</div>
                <div class="theorem-formula">${theorem.formula}</div>
                <div class="theorem-description">${theorem.details}</div>
            `;
        }
        
        // Draw circle theorem visualization
        function drawCircleTheorem(animate = false) {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw circle
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 150;
            
            // Draw circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = '#2c5364';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Draw center point
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#2c5364';
            ctx.fill();
            
            // Draw theorem-specific elements
            switch(currentTheorem) {
                case "angle-center":
                    drawCentralAngleTheorem(centerX, centerY, radius, animate);
                    break;
                case "angle-circumference":
                    drawAnglesSameSegment(centerX, centerY, radius, animate);
                    break;
                case "cyclic-quadrilateral":
                    drawCyclicQuadrilateral(centerX, centerY, radius, animate);
                    break;
                case "tangent-radius":
                    drawTangentRadius(centerX, centerY, radius, animate);
                    break;
                case "alternate-segment":
                    drawAlternateSegment(centerX, centerY, radius, animate);
                    break;
                case "chord-bisector":
                    drawChordBisector(centerX, centerY, radius, animate);
                    break;
                case "intersecting-chords":
                    drawIntersectingChords(centerX, centerY, radius, animate);
                    break;
                case "angle-semicircle":
                    drawAngleInSemicircle(centerX, centerY, radius, animate);
                    break;
            }
        }
        
        // Draw Central Angle Theorem
        function drawCentralAngleTheorem(centerX, centerY, radius, animate) {
            // Points A and B on circumference
            const angleA = Math.PI / 6; // 30 degrees
            const angleB = Math.PI / 2; // 90 degrees
            const angleC = Math.PI / 3; // 60 degrees (point on circumference)
            
            const pointA = {
                x: centerX + radius * Math.cos(angleA),
                y: centerY + radius * Math.sin(angleA)
            };
            
            const pointB = {
                x: centerX + radius * Math.cos(angleB),
                y: centerY + radius * Math.sin(angleB)
            };
            
            const pointC = {
                x: centerX + radius * Math.cos(angleC),
                y: centerY + radius * Math.sin(angleC)
            };
            
            // Draw triangle AOB (center to points A and B)
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(pointA.x, pointA.y);
            ctx.lineTo(pointB.x, pointB.y);
            ctx.closePath();
            ctx.strokeStyle = '#17a2b8';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw triangle ACB (points on circumference)
            ctx.beginPath();
            ctx.moveTo(pointA.x, pointA.y);
            ctx.lineTo(pointC.x, pointC.y);
            ctx.lineTo(pointB.x, pointB.y);
            ctx.closePath();
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw points
            drawPoint(centerX, centerY, 'O');
            drawPoint(pointA.x, pointA.y, 'A');
            drawPoint(pointB.x, pointB.y, 'B');
            drawPoint(pointC.x, pointC.y, 'C');
            
            // Calculate and display angles
            const centralAngle = angleB - angleA;
            const circumferenceAngle = centralAngle / 2;
            
            // Draw angle arcs
            drawAngleArc(centerX, centerY, angleA, centralAngle, 30, '#17a2b8');
            drawAngleArc(pointC.x, pointC.y, 
                Math.atan2(pointA.y - pointC.y, pointA.x - pointC.x),
                Math.atan2(pointB.y - pointC.y, pointB.x - pointC.x) - Math.atan2(pointA.y - pointC.y, pointA.x - pointC.x),
                20, '#28a745');
            
            // Display angle values
            drawAngleLabel(centerX, centerY, angleA + centralAngle/2, 40, `${(centralAngle * 180/Math.PI).toFixed(0)}°`);
            drawAngleLabel(pointC.x, pointC.y, 
                Math.atan2(pointA.y - pointC.y, pointA.x - pointC.x) + circumferenceAngle/2,
                25, `${(circumferenceAngle * 180/Math.PI).toFixed(0)}°`);
        }
        
        // Draw Angles in Same Segment Theorem
        function drawAnglesSameSegment(centerX, centerY, radius, animate) {
            // Fixed points A and B
            const angleA = Math.PI / 4; // 45 degrees
            const angleB = Math.PI; // 180 degrees
            
            // Two other points C and D on the same arc
            const angleC = Math.PI / 2.5; // ~72 degrees
            const angleD = Math.PI / 1.8; // ~100 degrees
            
            const pointA = getPointOnCircle(centerX, centerY, radius, angleA);
            const pointB = getPointOnCircle(centerX, centerY, radius, angleB);
            const pointC = getPointOnCircle(centerX, centerY, radius, angleC);
            const pointD = getPointOnCircle(centerX, centerY, radius, angleD);
            
            // Draw chord AB
            drawLine(pointA.x, pointA.y, pointB.x, pointB.y, '#6c757d', 1);
            
            // Draw triangles ACB and ADB
            drawTriangle(pointA, pointC, pointB, '#17a2b8');
            drawTriangle(pointA, pointD, pointB, '#28a745');
            
            // Draw points
            drawPoint(pointA.x, pointA.y, 'A');
            drawPoint(pointB.x, pointB.y, 'B');
            drawPoint(pointC.x, pointC.y, 'C');
            drawPoint(pointD.x, pointD.y, 'D');
            
            // Draw angles at C and D
            const angleACB = calculateAngle(pointA, pointC, pointB);
            const angleADB = calculateAngle(pointA, pointD, pointB);
            
            drawAngleArc(pointC.x, pointC.y, 
                Math.atan2(pointA.y - pointC.y, pointA.x - pointC.x),
                Math.atan2(pointB.y - pointC.y, pointB.x - pointC.x) - Math.atan2(pointA.y - pointC.y, pointA.x - pointC.x),
                20, '#17a2b8');
            
            drawAngleArc(pointD.x, pointD.y, 
                Math.atan2(pointA.y - pointD.y, pointA.x - pointD.x),
                Math.atan2(pointB.y - pointD.y, pointB.x - pointD.x) - Math.atan2(pointA.y - pointD.y, pointA.x - pointD.x),
                20, '#28a745');
            
            // Display angle values (they should be equal)
            drawAngleLabel(pointC.x, pointC.y, 
                Math.atan2(pointA.y - pointC.y, pointA.x - pointC.x) + angleACB/2,
                25, `${(angleACB * 180/Math.PI).toFixed(0)}°`);
            
            drawAngleLabel(pointD.x, pointD.y, 
                Math.atan2(pointA.y - pointD.y, pointA.x - pointD.x) + angleADB/2,
                25, `${(angleADB * 180/Math.PI).toFixed(0)}°`);
        }
        
        // Draw Cyclic Quadrilateral Theorem
        function drawCyclicQuadrilateral(centerX, centerY, radius, animate) {
            // Four points on the circle
            const angles = [Math.PI/6, Math.PI/2, Math.PI, 3*Math.PI/2];
            const points = angles.map(angle => getPointOnCircle(centerX, centerY, radius, angle));
            
            // Draw quadrilateral
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();
            ctx.strokeStyle = '#2c5364';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = 'rgba(44, 83, 100, 0.1)';
            ctx.fill();
            
            // Draw points and labels
            const labels = ['A', 'B', 'C', 'D'];
            points.forEach((point, i) => {
                drawPoint(point.x, point.y, labels[i]);
            });
            
            // Draw opposite angles
            const angleA = calculateAngle(points[3], points[0], points[1]);
            const angleC = calculateAngle(points[1], points[2], points[3]);
            
            drawAngleArc(points[0].x, points[0].y, 
                Math.atan2(points[3].y - points[0].y, points[3].x - points[0].x),
                Math.atan2(points[1].y - points[0].y, points[1].x - points[0].x) - Math.atan2(points[3].y - points[0].y, points[3].x - points[0].x),
                20, '#17a2b8');
            
            drawAngleArc(points[2].x, points[2].y, 
                Math.atan2(points[1].y - points[2].y, points[1].x - points[2].x),
                Math.atan2(points[3].y - points[2].y, points[3].x - points[2].x) - Math.atan2(points[1].y - points[2].y, points[1].x - points[2].x),
                20, '#28a745');
            
            // Display angle values (should sum to 180°)
            drawAngleLabel(points[0].x, points[0].y, 
                Math.atan2(points[3].y - points[0].y, points[3].x - points[0].x) + angleA/2,
                25, `${(angleA * 180/Math.PI).toFixed(0)}°`);
            
            drawAngleLabel(points[2].x, points[2].y, 
                Math.atan2(points[1].y - points[2].y, points[1].x - points[2].x) + angleC/2,
                25, `${(angleC * 180/Math.PI).toFixed(0)}°`);
            
            // Display sum
            ctx.fillStyle = '#2c5364';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(`∠A + ∠C = ${(angleA * 180/Math.PI).toFixed(0)}° + ${(angleC * 180/Math.PI).toFixed(0)}° = 180°`, centerX - 80, centerY + radius + 40);
        }
        
        // Helper functions for drawing
        function getPointOnCircle(centerX, centerY, radius, angle) {
            return {
                x: centerX + radius * Math.cos(angle),
                y: centerY + radius * Math.sin(angle)
            };
        }
        
        function drawPoint(x, y, label) {
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fillStyle = '#2c5364';
            ctx.fill();
            
            ctx.fillStyle = '#2c5364';
            ctx.font = 'bold 16px Arial';
            ctx.fillText(label, x + 8, y + 5);
        }
        
        function drawLine(x1, y1, x2, y2, color, width) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.stroke();
        }
        
        function drawTriangle(p1, p2, p3, color) {
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.closePath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function calculateAngle(p1, p2, p3) {
            const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
            const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };
            
            const dot = v1.x * v2.x + v1.y * v2.y;
            const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
            const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
            
            return Math.acos(dot / (mag1 * mag2));
        }
        
        function drawAngleArc(x, y, startAngle, angle, radius, color) {
            ctx.beginPath();
            ctx.arc(x, y, radius, startAngle, startAngle + angle);
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.stroke();
        }
        
        function drawAngleLabel(x, y, angle, distance, text) {
            const labelX = x + distance * Math.cos(angle);
            const labelY = y + distance * Math.sin(angle);
            
            ctx.fillStyle = '#2c5364';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, labelX, labelY);
            ctx.textAlign = 'left';
        }
        
        // Other theorem drawing functions (simplified for brevity)
        function drawTangentRadius(centerX, centerY, radius, animate) {
            // Draw tangent line
            const tangentPoint = getPointOnCircle(centerX, centerY, radius, Math.PI/4);
            const tangentLength = 100;
            
            // Tangent direction is perpendicular to radius
            const tangentDir = Math.atan2(tangentPoint.y - centerY, tangentPoint.x - centerX) + Math.PI/2;
            
            const tangentStart = {
                x: tangentPoint.x - tangentLength * Math.cos(tangentDir),
                y: tangentPoint.y - tangentLength * Math.sin(tangentDir)
            };
            
            const tangentEnd = {
                x: tangentPoint.x + tangentLength * Math.cos(tangentDir),
                y: tangentPoint.y + tangentLength * Math.sin(tangentDir)
            };
            
            // Draw tangent line
            drawLine(tangentStart.x, tangentStart.y, tangentEnd.x, tangentEnd.y, '#6c757d', 2);
            
            // Draw radius to tangent point
            drawLine(centerX, centerY, tangentPoint.x, tangentPoint.y, '#17a2b8', 2);
            
            // Draw right angle indicator
            const rightAngleSize = 15;
            const dir1 = Math.atan2(tangentPoint.y - centerY, tangentPoint.x - centerX);
            const dir2 = tangentDir;
            
            ctx.beginPath();
            ctx.moveTo(tangentPoint.x, tangentPoint.y);
            ctx.lineTo(tangentPoint.x + rightAngleSize * Math.cos(dir1), tangentPoint.y + rightAngleSize * Math.sin(dir1));
            ctx.lineTo(tangentPoint.x + rightAngleSize * Math.cos(dir1) + rightAngleSize * Math.cos(dir2), 
                       tangentPoint.y + rightAngleSize * Math.sin(dir1) + rightAngleSize * Math.sin(dir2));
            ctx.lineTo(tangentPoint.x + rightAngleSize * Math.cos(dir2), tangentPoint.y + rightAngleSize * Math.sin(dir2));
            ctx.closePath();
            ctx.strokeStyle = '#28a745';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw points
            drawPoint(centerX, centerY, 'O');
            drawPoint(tangentPoint.x, tangentPoint.y, 'P');
            
            // Add labels
            ctx.fillStyle = '#2c5364';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Tangent', tangentEnd.x - 30, tangentEnd.y - 10);
            ctx.fillText('Radius', (centerX + tangentPoint.x)/2 - 20, (centerY + tangentPoint.y)/2);
            ctx.fillText('90°', tangentPoint.x + 25, tangentPoint.y - 15);
        }
        
        function drawAlternateSegment(centerX, centerY, radius, animate) {
            // Simplified implementation
            ctx.fillStyle = '#2c5364';
            ctx.font = 'bold 18px Arial';
            ctx.fillText('Alternate Segment Theorem Visualization', centerX - 150, centerY - 50);
            ctx.fillText('∠ between tangent and chord = ∠ in alternate segment', centerX - 180, centerY + 50);
            
            // Draw a simple diagram
            const tangentPoint = getPointOnCircle(centerX, centerY, radius, Math.PI/4);
            const chordPoint = getPointOnCircle(centerX, centerY, radius, Math.PI/2);
            const altPoint = getPointOnCircle(centerX, centerY, radius, 3*Math.PI/4);
            
            drawLine(tangentPoint.x, tangentPoint.y, chordPoint.x, chordPoint.y, '#17a2b8', 2);
            drawLine(chordPoint.x, chordPoint.y, altPoint.x, altPoint.y, '#28a745', 2);
            
            drawPoint(tangentPoint.x, tangentPoint.y, 'T');
            drawPoint(chordPoint.x, chordPoint.y, 'A');
            drawPoint(altPoint.x, altPoint.y, 'B');
        }
        
        function drawChordBisector(centerX, centerY, radius, animate) {
            // Simplified implementation
            ctx.fillStyle = '#2c5364';
            ctx.font = 'bold 18px Arial';
            ctx.fillText('Chord Bisector Theorem Visualization', centerX - 140, centerY - 50);
            ctx.fillText('Perpendicular from center bisects the chord', centerX - 160, centerY + 50);
            
            // Draw a simple diagram
            const chordStart = getPointOnCircle(centerX, centerY, radius, Math.PI/3);
            const chordEnd = getPointOnCircle(centerX, centerY, radius, 2*Math.PI/3);
            const midpoint = {
                x: (chordStart.x + chordEnd.x) / 2,
                y: (chordStart.y + chordEnd.y) / 2
            };
            
            drawLine(chordStart.x, chordStart.y, chordEnd.x, chordEnd.y, '#17a2b8', 2);
            drawLine(centerX, centerY, midpoint.x, midpoint.y, '#28a745', 2);
            
            drawPoint(centerX, centerY, 'O');
            drawPoint(chordStart.x, chordStart.y, 'A');
            drawPoint(chordEnd.x, chordEnd.y, 'B');
            drawPoint(midpoint.x, midpoint.y, 'M');
        }
        
        function drawIntersectingChords(centerX, centerY, radius, animate) {
            // Simplified implementation
            ctx.fillStyle = '#2c5364';
            ctx.font = 'bold 18px Arial';
            ctx.fillText('Intersecting Chords Theorem Visualization', centerX - 160, centerY - 50);
            ctx.fillText('AP × PB = CP × PD', centerX - 80, centerY + 50);
            
            // Draw intersecting lines
            const p1 = getPointOnCircle(centerX, centerY, radius, Math.PI/6);
            const p2 = getPointOnCircle(centerX, centerY, radius, 5*Math.PI/6);
            const p3 = getPointOnCircle(centerX, centerY, radius, Math.PI/2);
            const p4 = getPointOnCircle(centerX, centerY, radius, 3*Math.PI/2);
            
            // Intersection point (simplified)
            const intersectX = centerX;
            const intersectY = centerY;
            
            drawLine(p1.x, p1.y, p2.x, p2.y, '#17a2b8', 2);
            drawLine(p3.x, p3.y, p4.x, p4.y, '#28a745', 2);
            
            drawPoint(p1.x, p1.y, 'A');
            drawPoint(p2.x, p2.y, 'B');
            drawPoint(p3.x, p3.y, 'C');
            drawPoint(p4.x, p4.y, 'D');
            drawPoint(intersectX, intersectY, 'P');
        }
        
        function drawAngleInSemicircle(centerX, centerY, radius, animate) {
            // Draw diameter
            const pointA = { x: centerX - radius, y: centerY };
            const pointB = { x: centerX + radius, y: centerY };
            const pointC = { x: centerX, y: centerY - radius };
            
            drawLine(pointA.x, pointA.y, pointB.x, pointB.y, '#17a2b8', 3);
            drawLine(pointA.x, pointA.y, pointC.x, pointC.y, '#28a745', 2);
            drawLine(pointB.x, pointB.y, pointC.x, pointC.y, '#28a745', 2);
            
            // Draw right angle indicator at C
            const rightAngleSize = 15;
            ctx.beginPath();
            ctx.moveTo(pointC.x, pointC.y);
            ctx.lineTo(pointC.x - rightAngleSize, pointC.y);
            ctx.lineTo(pointC.x - rightAngleSize, pointC.y + rightAngleSize);
            ctx.lineTo(pointC.x, pointC.y + rightAngleSize);
            ctx.closePath();
            ctx.strokeStyle = '#dc3545';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            drawPoint(pointA.x, pointA.y, 'A');
            drawPoint(pointB.x, pointB.y, 'B');
            drawPoint(pointC.x, pointC.y, 'C');
            
            // Add labels
            ctx.fillStyle = '#2c5364';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('Diameter', centerX - 30, centerY + 20);
            ctx.fillText('90°', pointC.x - 25, pointC.y + 30);
        }
        
        // Show hint for current theorem
        function showHint() {
            const theorem = theorems[currentTheorem];
            
            hintContent.innerHTML = `
                <div class="method-step"><strong>Theorem:</strong> ${theorem.name}</div>
                <div class="method-step"><strong>Statement:</strong> ${theorem.description}</div>
                <div class="method-step"><strong>Formula:</strong> ${theorem.formula}</div>
                <div class="method-step"><strong>Explanation:</strong> ${theorem.hint}</div>
                <div class="method-step"><strong>Key Insight:</strong> ${theorem.details}</div>
            `;
            
            hintContainer.style.display = "block";
            addToHistory(`Viewed hint for ${theorem.name}`, true);
        }
        
        // Show quiz for current theorem
        function showQuiz() {
            const theorem = theorems[currentTheorem];
            const quiz = quizQuestions[currentTheorem];
            
            quizQuestionEl.textContent = quiz.question;
            
            // Clear previous options
            quizOptionsEl.innerHTML = '';
            
            // Add new options
            quiz.options.forEach((option, index) => {
                const optionEl = document.createElement('div');
                optionEl.className = 'quiz-option';
                optionEl.textContent = option;
                optionEl.dataset.index = index;
                
                optionEl.addEventListener('click', function() {
                    // Remove selected class from all options
                    document.querySelectorAll('.quiz-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    
                    // Add selected class to clicked option
                    this.classList.add('selected');
                });
                
                quizOptionsEl.appendChild(optionEl);
            });
            
            // Reset UI state
            submitQuizBtn.style.display = 'flex';
            nextQuizBtn.style.display = 'none';
            quizContainerEl.style.display = 'block';
            feedbackEl.style.display = 'none';
            
            // Scroll to quiz
            quizContainerEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        // Check quiz answer
        function checkQuizAnswer() {
            const selectedOption = document.querySelector('.quiz-option.selected');
            
            if (!selectedOption) {
                showFeedback("Please select an answer first!", "incorrect");
                return;
            }
            
            const selectedIndex = parseInt(selectedOption.dataset.index);
            const quiz = quizQuestions[currentTheorem];
            const isCorrect = selectedIndex === quiz.correct;
            
            // Show correct/incorrect feedback
            if (isCorrect) {
                score += 20;
                streak++;
                totalSolved++;
                
                // Mark theorem as mastered if not already
                if (!masteredTheorems.has(currentTheorem)) {
                    masteredTheorems.add(currentTheorem);
                    masteryProgress = Math.floor((masteredTheorems.size / 8) * 100);
                    
                    // Check for level up
                    if (masteredTheorems.size >= level * 2 && level < 4) {
                        level++;
                        showFeedback(`Level Up! You're now at level ${level}. Great work!`, "correct");
                    }
                }
                
                showFeedback("Correct! Well done! +20 points", "correct");
            } else {
                streak = 0;
                showFeedback("Incorrect. Try again or review the theorem explanation.", "incorrect");
            }
            
            // Highlight correct answer
            document.querySelectorAll('.quiz-option').forEach((option, index) => {
                if (index === quiz.correct) {
                    option.classList.add('correct');
                } else if (index === selectedIndex && !isCorrect) {
                    option.classList.add('incorrect');
                }
                option.style.pointerEvents = 'none'; // Disable further clicks
            });
            
            // Update stats display
            updateStats();
            
            // Show next button
            submitQuizBtn.style.display = 'none';
            nextQuizBtn.style.display = 'flex';
            
            // Add to history
            addToHistory(`Quiz on ${theorems[currentTheorem].name}`, isCorrect);
        }
        
        // Update game stats
        function updateStats() {
            scoreEl.textContent = score;
            streakEl.textContent = streak;
            totalEl.textContent = totalSolved;
            levelEl.textContent = level;
            theoremsMasteredEl.textContent = `${masteredTheorems.size}/8`;
            progressEl.style.width = `${masteryProgress}%`;
            progressPercentEl.textContent = `${masteryProgress}%`;
        }
        
        // Show feedback message
        function showFeedback(message, type) {
            feedbackEl.textContent = message;
            feedbackEl.className = `feedback ${type}`;
            feedbackEl.style.display = 'block';
            
            // Add animation
            feedbackEl.classList.add('pulse');
            setTimeout(() => feedbackEl.classList.remove('pulse'), 500);
        }
        
        // Add activity to history
        function addToHistory(activity, success) {
            const historyItem = {
                activity,
                success,
                timestamp: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})
            };
            
            history.unshift(historyItem);
            
            // Keep only last 5 items
            if (history.length > 5) history.pop();
            
            renderHistory();
        }
        
        // Render history list
        function renderHistory() {
            historyList.innerHTML = "";
            
            history.forEach(item => {
                const historyItemEl = document.createElement('div');
                historyItemEl.className = 'history-item';
                
                historyItemEl.innerHTML = `
                    <div>
                        <div class="history-theorem">${item.activity}</div>
                        <div style="font-size: 0.8rem; color: #666;">${item.timestamp}</div>
                    </div>
                    <div style="text-align: center;">
                        ${item.success ? 
                            '<i class="fas fa-check-circle correct-icon"></i>' : 
                            '<i class="fas fa-times-circle incorrect-icon"></i>'}
                    </div>
                `;
                
                historyList.appendChild(historyItemEl);
            });
        }
        
        // Reset game
        function resetGame() {
            if (confirm("Are you sure you want to reset the game? Your progress will be lost.")) {
                score = 0;
                streak = 0;
                totalSolved = 0;
                level = 1;
                masteryProgress = 0;
                masteredTheorems.clear();
                history = [];
                
                // Reset UI
                updateStats();
                
                // Reset to first theorem
                document.querySelectorAll('.theorem-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelector('[data-theorem="angle-center"]').classList.add('active');
                currentTheorem = "angle-center";
                
                // Update displays
                updateTheoremInfo();
                drawCircleTheorem();
                
                // Hide containers
                quizContainerEl.style.display = 'none';
                hintContainer.style.display = 'none';
                feedbackEl.style.display = 'none';
                
                // Add initial history
                addToHistory("Started new game", true);
            }
        }
        
        // Initialize the game when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>